[{"body":"シリーズ記事を書く機運 　しばらく放ったらかしだったこのブログにも書くネタはあるのでシリーズ記事を書いてみたい。それに先立ち、記事内に埋め込む「同一シリーズの記事一覧」機能を自作した。\nShortcode series.html\n{{ $name := .Get \u0026#34;name\u0026#34; }} \u0026lt;h3\u0026gt;Series: {{ $name }}\u0026lt;/h3\u0026gt; \u0026lt;ul class=\u0026#34;page-list\u0026#34;\u0026gt; {{ range $key, $series := site.Taxonomies.series }} {{ if eq $key $name }} {{ range $series.Pages }} \u0026lt;li\u0026gt; \u0026lt;span class=\u0026#34;list-date\u0026#34;\u0026gt;{{ .Date.Format \u0026#34;2006/01/02\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title | markdownify }}\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} {{ end }} {{ end }} \u0026lt;/ul\u0026gt; 設定 config.toml\n[taxonomies] tag = \u0026quot;tags\u0026quot; archive = \u0026quot;archives\u0026quot; series = \u0026quot;series\u0026quot; 　taxonomies に series を追加する。これでデフォルトで用意されている tag のように使えるようになる。\n記事のメタ情報 tag のようにページヘッダに記述。\nseries: [\u0026quot;シリーズを追加\u0026quot;] 利用法 https://github.com/tbsmcd/tbsmcd.github.io/blob/b84e2829c021b40eb128440685259d9654b69086/content/post/series-list/index.md\n「実際の表示」参照\n実際の表示↓ Series: シリーズを追加  2020/10/20 hugo でシリーズ記事一覧を表示するための Shortcode と設定   2020/10/20 Taxonomy「シリーズ」を追加するテスト   ポイント 　{{ range $key, $series := site.Taxonomies.series }} で foreach (series as key =\u0026gt; value) のような動きができること。\n","date":"2020-10-20","id":1,"title":"hugo でシリーズ記事一覧を表示するための Shortcode と設定","url":"/post/series-list/"},{"body":" Series: シリーズを追加  2020/10/20 hugo でシリーズ記事一覧を表示するための Shortcode と設定   2020/10/20 Taxonomy「シリーズ」を追加するテスト   ","date":"2020-10-20","id":2,"title":"Taxonomy「シリーズ」を追加するテスト","url":"/post/test-series/"},{"body":"他のページに遷移した場合にスタイルが崩れます。遷移後リロードしてください。\n読書アシストを適用してみた DNP\u0026nbsp;の開発した「読書アシスト」を\u0026nbsp;hugo\u0026nbsp;で利用する実験をしているので、これはあえて分かりにくい文章にするつもりだったが、実際のところ酔っ払っているのでこのまま勢いに任せてタイピングしていけば訳のわからない文章になることはうけあいだ。きょうは博多駅のヨドバシカメラに行ってオーブンレンジを買った。子供が生まれると金がかかりますね。先週はトヨタのディーラーに行ったので……まあ福岡に住んでいて車を持っていないというのも不便な話なので良い機会だったと思っている。オーブンレンジも、まあ買ってよかったものになるんじゃないかな。こんな感じにグダグダの文章を書いてみてよいのだろうか？  \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;     読書アシスト\nソースの取得 　今回は Pyhton で以下のようなスクリプトを書いた。\n#!/usr/bin/env python3 import requests from pprint import pprint text = \u0026#34;\u0026#34;\u0026#34;DNP の開発した「読書アシスト」を hugo で利用する実験をしているので、これはあえて分かりにくい文章にするつもりだったが、\\ 実際のところ酔っ払っているのでこのまま勢いに任せてタイピングしていけば訳のわからない文章になることはうけあいだ。\\ きょうは博多駅のヨドバシカメラに行ってオーブンレンジを買った。子供が生まれると金がかかりますね。\\ 先週はトヨタのディーラーに行ったので……まあ福岡に住んでいて車を持っていないというのも不便な話なので良い機会だったと思っている。\\ オーブンレンジも、まあ買ってよかったものになるんじゃないかな。こんな感じにグダグダの文章を書いてみてよいのだろうか？\u0026#34;\u0026#34;\u0026#34; url = \u0026#39;https://reading-assist.com/api/assistapi.php\u0026#39; item_data = { \u0026#39;action\u0026#39;: \u0026#39;conv_htmltext\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;かいもの\u0026#39;, \u0026#39;htmlText\u0026#39;: text } print(requests.post(url, data=item_data).content.decode()) 　このスクリプトを実行したら1ページ分の html を取得できる。今回はページ内のコンテンツとして使いたいので \u0026lt;div class=\u0026quot;textblock\u0026quot;\u0026gt; を抜き出した。 CSS は以下のようにプリロードにした。jquery-mobile もそのままにしてある。ただしそのためにスタイルが崩れるので別のページに遷移した場合はリロードしてほしい。また、 html を Markdown に埋め込むにあたり raw shortcodes を使った。\n　実際の Markdown ファイルは Github にあるので見てほしい。\n","date":"2020-07-11","id":3,"title":"DNP が開発した「読書アシスト」を hugo で試す","url":"/post/dnp-reading-asist/"},{"body":"hugo new のダルさ 　hugo で新規記事を作るときはコマンドラインでhugo new を打つ。たとえば http://ドメイン/sample-article という記事を作りたい場合、\n hugo new post/sample-article/index.md を実行する  ./contetn/post/sample-article/index.md が作成される   エディタで作成された index.md を開き記事を書く 画像を ./content/post/sample-article/ 以下に配置する  たったこれだけを実行すればよいのだが、やってみると案外ダルい。自分としてはダルさが明確で\n hugo new post/dir-name/index.md なのか hugo new content/post/dir-name/index.md なのか hugo new posts/dir-name/index.md なのか分からなくなる hugo new コマンドでは post/dir-name/index.mdを指定したのにエディタではcontent/post/dir-name/index.md` を指定して開かないといけない 画像を載せたい場合はほぼ同じ path である content/post/dir-name/ を開いて画像を配置しなければならない  というふうに、重複がダルい。これはプログラマの美徳でいう「怠惰」精神の発露といえよう（ダルいと怠惰はほとんど同じ言葉なのだけど）。\n　index.md の雛形は archetypes/default.md に書いておけば反映されるのでさほど面倒ではない。例えばこのブログの場合は以下のようになっている。\n--- title: \u0026quot;\u0026quot; description: \u0026quot;\u0026quot; image: \u0026quot;\u0026quot; date: {{ .Date }} tags: [] archives: [\u0026quot;{{ dateFormat \u0026quot;2006-01\u0026quot; .Date }}\u0026quot;] draft: true --- date や archives の部分の日付は勝手に補完されるし、ふつうに考えればとても便利！しかしこれを編集する手間も省きたいのが人情というもの。そこで最近は Pyhton スクリプトを書いて、対話的に記事を作っている。\nPython スクリプト #!/usr/bin/env python3 import os import datetime from subprocess import run def input_dir_name(): name = input(\u0026#39;Directory name: \u0026#39;).replace(\u0026#39;_\u0026#39;, \u0026#39;-\u0026#39;) print(name) path = os.path.dirname(__file__) + \u0026#39;/content/post/{0}\u0026#39;.format(name) if os.path.exists(path): edit = input(\u0026#39;This dir_name exists. Edit this page?(Y/n) : \u0026#39;) if edit == \u0026#39;y\u0026#39; or edit == \u0026#39;Y\u0026#39;: return name, False print(\u0026#39;Please use other name.\u0026#39;) input_dir_name() else: return name, True try: dir_name, is_new = input_dir_name() dir_path = os.path.dirname(__file__) + \u0026#39;/content/post/{0}\u0026#39;.format(dir_name) if is_new is True: print(\u0026#39;Create new page.\u0026#39;) title = input(\u0026#39;Title: \u0026#39;) desc = input(\u0026#39;Description: \u0026#39;) img = input(\u0026#39;OGP image: \u0026#39;) tags = input(\u0026#39;Tags(comma separated): \u0026#39;) draft = input(\u0026#39;Draft(Y/n): \u0026#39;) print(\u0026#39;Creating page: {0}/index.md\u0026#39;.format(dir_path)) # タグを整理する tags_list = [\u0026#39;\u0026#34;{0}\u0026#34;\u0026#39;.format(x.strip()) for x in tags.split(\u0026#39;,\u0026#39;)] tags_str = \u0026#39;, \u0026#39;.join(tags_list) # is draft if draft == \u0026#39;y\u0026#39; or draft == \u0026#39;Y\u0026#39;: is_draft = \u0026#39;true\u0026#39; else: is_draft = \u0026#39;false\u0026#39; dt_now = datetime.datetime.now() header = \u0026#34;\u0026#34;\u0026#34;---title: \u0026#34;{0}\u0026#34;description: \u0026#34;{1}\u0026#34;image: \u0026#34;{2}\u0026#34;date: {3}tags: [{4}]archives: [\u0026#34;{5}\u0026#34;]draft: {6}---\u0026#34;\u0026#34;\u0026#34;.format(title, desc, img, dt_now.strftime(\u0026#39;%Y-%m-%dT%H:%M:%S+09:00\u0026#39;), tags_str, dt_now.strftime(\u0026#39;%Y-%m\u0026#39;), is_draft) # ファイル作成 os.makedirs(dir_path, exist_ok=True) with open(dir_path + \u0026#39;/index.md\u0026#39;, mode=\u0026#39;w\u0026#39;) as f: f.write(header) else: print(\u0026#39;Edit page.\u0026#39;) # 規定のエディタを取得して編集 EDITOR = os.environ.get(\u0026#39;EDITOR\u0026#39;, \u0026#39;vim\u0026#39;) run([EDITOR, dir_path + \u0026#39;/index.md\u0026#39;]) open_finder = input(\u0026#39;Open in Finder?(Y/n): \u0026#39;) if open_finder == \u0026#39;y\u0026#39; or open_finder == \u0026#39;Y\u0026#39;: run([\u0026#39;open\u0026#39;, dir_path]) print(\u0026#39;Finished.\u0026#39;) except KeyboardInterrupt: print(\u0026#39;\\nStopped(Keyboard Interrupt).\u0026#39;) リンク\nこれをコマンドラインで実行すると、以下のように対話的にメタ情報を求められ、結果は index.md に反映される。あとはエディタが index.md を開いてくれるので編集するだけ。おまけとして画像を配置するための open コマンドも Open in Finder?(Y/n):  として対話的に実行しているので、ストレスフリーが実現する（最高だね）。\n➤ ./create.py Directory name: tired-from-hugo-new tired-from-hugo-new Create new page. Title: hugo new で記事を新規作成するのは少しダルいから自作スクリプトで編集する Description: hugo new で記事を新規作成するのは少しダルいので Pyhton で対話的に記事を作成できるスクリプトを書いて使用している。 OGP image: program.png Tags(comma separated): hugo, Python Draft(Y/n): n まとめ hugo はよく出来ている。しかしよく出来ているソフトウェアも、自分に合わない部分がある。それならば適当なスクリプトで修正していけば良い。もしくは Pull Request を送ろう。幸い hugo は markdown という比較的単純なテキストファイルをベースに記事を作成する。テキストファイルを介して hugo と自作スクリプト間をやり取りするのは、 UNIX 的ともいえるのではないか。そういう気持ちで各自やっていけばアウトプットが楽になるのではないかと思う。\n","date":"2020-07-09","id":4,"title":"hugo new で記事を新規作成すると少しダルいから自作スクリプトで編集する","url":"/post/tired-from-hugo-new/"},{"body":"記録  月 火 水 木 金 土 日  所感 　この週はストリクトを意識できたと思う。特に回数にこだわらず1回を重視できている。\n","date":"2020-07-05","id":5,"title":"2020-06-29 の週のトレーニングノート","url":"/post/training_note_20200629/"},{"body":"記録  月 火 水 木 金 土 日  所感 全体的に負荷に不満を感じ始めている。フォームが悪かったりストリクトを意識できてないかもしれない。\n","date":"2020-06-28","id":6,"title":"2020-06-22 の週のトレーニングノート","url":"/post/training_note_20200622/"},{"body":"記録  月 火 水 木 金 土 日  所感 会社の評価期間の影響で1日出来なかった。疲れを感じていたので休養とした。\n","date":"2020-06-28","id":7,"title":"2020-06-15 の週のトレーニングノート","url":"/post/training_note_20200615/"},{"body":"記録  月 火 水 木 金 土 日  所感 ピストルスクワット（補助）を入れて脚の負荷が満足行くものとなった。\n","date":"2020-06-28","id":8,"title":"2020-06-08 の週のトレーニングノート","url":"/post/training_note_20200608/"},{"body":"記録  月 火 水 木 金 土 日  所感 金曜日は片頭痛のため行えていない。 曜日固定を忘れ、土日に不足分を行うのも良いだろう。\n","date":"2020-06-28","id":9,"title":"2020-06-01 の週のトレーニングノート","url":"/post/training_note_20200601/"},{"body":"  『Python 機械学習プログラミング 達人データサイエンティストによる理論と実践』を写経しながら進めている。第3章で scikit-learn を使うのだが、記載通りに書いても動かない部分があったのでメモ。\n54ページから55ページにかけて\nfrom sklearn.linear_model import Perceptron ppn = Perceptron(n_iter=40, eta0=0.1, random_state=1) # 以下略 というコードがあるが、このまま実行しても\nTypeError: __init__() got an unexpected keyword argument 'n_iter' となる。\n現在の stable release は version 0.23 であるが、変更履歴をたどると、version 0.20 のドキュメントに The number of passes over the training data (aka epochs). Defaults to None. Deprecated, will be removed in 0.21. Changed in version 0.19: Deprecated とあり、非推奨を経て削除済みだと分かる。かわりに max_iter が  (aka epochs) とされているのでこれを使ったら良さそうだ。\n","date":"2020-06-13","id":10,"title":"sklearn.linear_model.Perceptron のパラメータから n_iter が削除されてた件のメモ","url":"/post/max_iter/"},{"body":"  子供を見守るには移動をしやすい机が必要 一般的にスタンディングデスクとは座りっぱなしを防ぐためのものだ。しかし人によっては他の機能を求めることもある。例えば子の動きを見張るためにリビングでも使いたいとか。まさにそのためにポータブルなスタンディングデスクを探していたのだけど、実質的には机ではなく司会台なのでは？という物品がテーブルとして売られていたので購入した。\n (Amazon)\n脚の数を見れば安定性にかけるのは明らかだけど、しかしタイピングしてみても不満はない。案外こういうものでも要求を満たすものだということは覚えておこう。\n本を置くのには狭いから拡張しよう 面積の大きな机はポータビリティという面で劣るので採用したくはない。ディスプレイのようにアームを付けるしかないだろう。しかしアーム付きの書見台は多くはない……が、無くはない。\n (Amazon)\nこちらの書見台は同メーカーのものをすでに使っていたこともあり、信頼ができたので購入した。\n完成図  Python 機械学習プログラミング 達人データサイエンティストによる理論と実践 （Amazon リンク） を進めるうえで、とても役に立っている。休日に子の様子を見ないといけないとき、眠くて集中出来ないとき。スタンディングデスクの良さと、身軽さと、便利さを全部叶えることが出来たと思っている。\n費用 司会台（？）はテーブル名目で売られていたので、勤務先である GMO ペパボの「リモートワーク快適化支援」のうちデスク購入費の補助を用いて一部を経費精算出来た。机以外にも椅子やディスプレイも経費精算できるので宣伝しておこう。\n","date":"2020-06-05","id":11,"title":"子供の見守りもできる最高のスタンディングデスク環境","url":"/post/perfect_standing_desk/"},{"body":"前回の続き。\nダークモードを使いたいんだ！ わざわざ Jupyter を IntelliJ IDEA/PyCharm や VS Code から使う理由の1つに「ふだん使いのカラースキームを使いたいから」というのがある。しかしダークモードで Jupyter を使いグラフを表示すると、透過部分の文字が読みにくく残念な状態になる。\n 同じように困っている人はそれなりにいるらしい（例: Google \u0026ldquo;pycharm dark theme jupyter\u0026rdquo;）。 IDE 側の色設定で何とかしようとしている人もいるが、この場合 plt.style.use() でグラフのスタイルを変更したほうがはやい。\n 画像では plt.style.use(['dark_background']) としている（中2病っぽくて好き）。ほかにも default などがあり（ default がデフォルトじゃなくて謎）、適切に選択すればダークモードの IDE と Jupyter Notebook の標準的なカラースキームとで違和感なく共存できる。詳しくは公式ドキュメント （リンク1 リンク2）参照。\n","date":"2020-06-01","id":12,"title":"ダークモード環境で Jupyter Notebook を使ってグラフを表示する場合の style 設定","url":"/post/jupyter_plt_darkmode/"},{"body":"前提 Jupyter Notebook を使っていると、ふだん使っている IDE のカラースキームが懐かしくなったり、Python ファイルでちょっとした関数を定義したくて IDE との往復が発生したりする（した）。\n環境  IntelliJ IDEA 2020.1(ULTIMATE EDITION) で検証。PyCharm でも同様だと思う macOS 10.14.6 Python 3.7.7（Homebrew） Jupyter Notebook 6.0.3（pip3 install jupyter）  仮想環境を使ってもたぶんあまり変わらない。Anaconda は使っていてダルくなったので現在は削除している（またいずれ使うだろうが）。\n手順  新規プロジェクトを作成する。  *.ipynb ファイルを作成する。この画面の場合、左が編集エリアで右がプレビューエリアになっている。  画面右上で編集のみ、編集とプレビュー、プレビューのみを選択できる。  「すべて実行」をクリックする。まだ Jupyter Notebook サーバは起動していない。カーネルを選択するよう求められるので Python 3 を選ぶ。  もしくは他のサーバを選ぶこともできる。これは上記カーネルの画像にある マネージド http://〜 の箇所をクリックし Jupyter サーバーの構成 を選択すれば良い。  無事動いた。\n","date":"2020-05-31","id":13,"title":"Jupyter Notebook を PyCharm（or IntelliJ IDEA）上で使う","url":"/post/jetbrains_jupyter/"},{"body":"記録  月 火 水 木 金 土 日  リンクのない曜日は rest 。トリフェクタは毎日実施……出来てないな。\n所感 片頭痛のため月曜は休み。プルアップとジャックナイフプッシュアップに進展。\n","date":"2020-05-31","id":14,"title":"2020-05-25 の週のトレーニングノート","url":"/post/training_note_20200525/"},{"body":"記録  月 火 水 木 金 土 日  リンクのない曜日は rest 。トリフェクタは毎日実施している。\n所感 肩と脚の負荷について意識し実践できている。\n","date":"2020-05-31","id":15,"title":"2020-05-18 の週のトレーニングノート","url":"/post/training_note_20200518/"},{"body":"記録  月 火 水 木 金 土 日  リンクのない曜日は rest 。毎日トリフェクタは実施している。\n所感 プルアップに進展が見られる。\n","date":"2020-05-31","id":16,"title":"2020-05-11 の週のトレーニングノート","url":"/post/training_note_20200511/"},{"body":"  言語処理100本ノック 2020 - NLP100 2020\n関連記事: tag 言語処理100本ノック\n所感 いよいよタームの難度が上がってきた。\ncode 040 #!/usr/local/bin/python3 class Morph: def __init__(self, word): self.surface = word[\u0026#39;surface\u0026#39;] self.base = word[\u0026#39;base\u0026#39;] self.pos = word[\u0026#39;pos\u0026#39;] self.pos1 = word[\u0026#39;pos1\u0026#39;] src = \u0026#39;neko.txt.cabocha\u0026#39; with open(src) as f: sentence_list = f.read().split(\u0026#39;EOS\\n\u0026#39;) sentence_list = [x for x in sentence_list if x != \u0026#39;\u0026#39;] morph_list = [] for sentence in sentence_list: words_list = [] for word in sentence.strip().split(\u0026#39;\\n\u0026#39;): if word[0] == \u0026#39;*\u0026#39;: continue (surface, attr) = word.split(\u0026#39;\\t\u0026#39;) attr = attr.split(\u0026#39;,\u0026#39;) morph = Morph({ \u0026#39;surface\u0026#39;: surface, \u0026#39;base\u0026#39;: attr[6], \u0026#39;pos\u0026#39;: attr[0], \u0026#39;pos1\u0026#39;: attr[1] }) words_list.append(morph) morph_list.append(words_list) for m in morph_list[2]: print(vars(m)) 041 以下、前の課題で使ったコードは省略する\n# 041 for chunk in sentence_chunks[7]: print(vars(chunk)) for morph in chunk.morphs: print(vars(morph)) 042 # 042 for sentence in sentence_chunks: for chunk in sentence: if int(chunk.dst) != -1: print( \u0026#39;\u0026#39;.join([m.surface for m in chunk.morphs if m.pos != \u0026#39;記号\u0026#39;]) + \u0026#39;\\t\u0026#39; + \u0026#39;\u0026#39;.join([m.surface for m in sentence[int(chunk.dst)].morphs if m.pos != \u0026#39;記号\u0026#39;]) ) 043 for sentence in sentence_chunks: for chunk in sentence: if int(chunk.dst) != -1: if \u0026#39;名詞\u0026#39; in [m.pos for m in chunk.morphs] and \u0026#39;動詞\u0026#39; in [m.pos for m in sentence[int(chunk.dst)].morphs]: print( \u0026#39;\u0026#39;.join([m.surface for m in chunk.morphs if m.pos != \u0026#39;記号\u0026#39;]) + \u0026#39;\\t\u0026#39; + \u0026#39;\u0026#39;.join([m.surface for m in sentence[int(chunk.dst)].morphs if m.pos != \u0026#39;記号\u0026#39;]) ) 044 rel = [] # 041 に準じて8文目だけを対象にする sentence = sentence_chunks[7] for chunk in sentence: if int(chunk.dst) != -1: modifier = \u0026#39;\u0026#39;.join([m.surface for m in chunk.morphs if m.pos != \u0026#39;記号\u0026#39;]) modifiee = \u0026#39;\u0026#39;.join([m.surface for m in sentence[int(chunk.dst)].morphs if m.pos != \u0026#39;記号\u0026#39;]) rel.append([modifier, modifiee]) g = pydot.graph_from_edges(rel) g.write_png(\u0026#39;044.png\u0026#39;, prog=\u0026#39;dot\u0026#39;) 045 for sentence in sentence_chunks: rel = {} for key, chunk in enumerate(sentence): morphs = [m for m in chunk.morphs if m.pos == \u0026#39;動詞\u0026#39;] if len(morphs) \u0026gt; 0: predicate = morphs[0].base cases = [] for src in chunk.srcs: cases.extend([m.surface for m in sentence[src].morphs if m.pos == \u0026#39;助詞\u0026#39;]) case = \u0026#39;\u0026#39;.join(cases) if case != \u0026#39;\u0026#39;: print(predicate + \u0026#39;\\t\u0026#39; + case) $ python3 45.py \u0026gt; 45.txt # コーパス中で頻出する述語と格パターンの組み合わせ $ cat 45.txt | sort | uniq -c | sort -nr | head -n 50 # 「する」「見る」「与える」という動詞の格パターン $ cat 45.txt | grep \u0026#39;見る\u0026#39; | sort | uniq -c | sort -nr | head -n 50 046 for sentence in sentence_chunks: rel = {} for key, chunk in enumerate(sentence): morphs = [m for m in chunk.morphs if m.pos == \u0026#39;動詞\u0026#39;] if len(morphs) \u0026gt; 0: predicate = morphs[0].base cases = [] arguments = [] for src in chunk.srcs: if src != key: cases.extend([m.surface for m in sentence[src].morphs if m.pos == \u0026#39;助詞\u0026#39;]) arguments.append(\u0026#39;\u0026#39;.join([m.surface for m in sentence[src].morphs])) case = \u0026#39;\u0026#39;.join(cases) argument = \u0026#39;\u0026#39;.join(arguments) if case != \u0026#39;\u0026#39;: print(predicate + \u0026#39;\\t\u0026#39; + case + \u0026#39;\\t\u0026#39; + argument) 047 for sentence in sentence_chunks: rel = {} for key, chunk in enumerate(sentence): if (\u0026#39;サ変接続\u0026#39; in [m.pos1 for m in chunk.morphs] and \u0026#39;を\u0026#39; in [m.surface for m in chunk.morphs] and key \u0026lt; len(sentence) - 1 and sentence[key + 1].morphs[0].pos == \u0026#39;動詞\u0026#39; ): # 述語 predicate = \u0026#39;\u0026#39;.join([m.surface for m in chunk.morphs]) + sentence[key + 1].morphs[0].base if len(chunk.srcs) \u0026gt; 0: modifiers = [sentence[int(src)].morphs for src in chunk.srcs] modifiers_ = [list(filter(lambda x: \u0026#39;助詞\u0026#39; in x.pos, morphs)) for morphs in modifiers] modifiers_surfaces = [[morph.surface for morph in morphs] for morphs in modifiers_] modifiers_surfaces = list(filter(lambda x: x != [], modifiers_surfaces)) modifiers_surfaces = [morphs[0] for morphs in modifiers_surfaces] # print(modifiers_surfaces) modifiers_texts = list(filter(lambda x: \u0026#39;助詞\u0026#39; in [m.pos for m in x], modifiers)) modifiers_texts = [\u0026#39;\u0026#39;.join([m.surface for m in mt]) for mt in modifiers_texts] if len(modifiers_texts) \u0026gt; 0: print(\u0026#39;\\t\u0026#39;.join([predicate, \u0026#39;\u0026#39;.join(modifiers_surfaces), \u0026#39;\u0026#39;.join(modifiers_texts)])) $ python3 47.py \u0026gt; 47.txt $ cut -f 1 47.txt | sort | uniq -c | sort -nr | head $ cut -f 1,2 47.txt | sort | uniq -c | sort -nr | head 048 for sentence in sentence_chunks: for chunk in sentence: texts = [] if len([morph for morph in chunk.morphs if morph.pos == \u0026#39;名詞\u0026#39;]) \u0026gt; 0 and chunk.dst != -1: current_chunk = chunk texts.append(\u0026#39;\u0026#39;.join([morph.surface for morph in current_chunk.morphs])) next_chunk = sentence[int(current_chunk.dst)] while int(current_chunk.dst) != -1: texts.append(\u0026#39;\u0026#39;.join([morph.surface for morph in next_chunk.morphs])) current_chunk = next_chunk next_chunk = sentence[next_chunk.dst] print(\u0026#39;-\u0026gt; \u0026#39;.join(texts)) 049 def convert(sentence): pl, nl = [], [chunk for chunk in sentence if \u0026#39;名詞\u0026#39; in [m.pos for m in chunk.morphs]] for i in range(len(nl) - 1): st1 = [\u0026#39;\u0026#39;.join([m.surface if m.pos != \u0026#39;名詞\u0026#39; else \u0026#39;X\u0026#39; for m in nl[i].morphs])] for e in nl[i + 1:]: dst, p = nl[i].dst, [] st2 = [\u0026#39;\u0026#39;.join([m.surface if m.pos != \u0026#39;名詞\u0026#39; else \u0026#39;Y\u0026#39; for m in e.morphs])] while int(dst) != -1 and dst != sentence.index(e): p.append(sentence[int(dst)]) dst = sentence[int(dst)].dst if len(p) \u0026lt; 1 or p[-1].dst != -1: mid = [\u0026#39;\u0026#39;.join([m.surface for m in c.morphs if m.pos != \u0026#39;記号\u0026#39;]) for c in p] pl.append(st1 + mid + [\u0026#39;Y\u0026#39;]) else: mid, dst = [], e.dst while not sentence[int(dst)] in p: mid.append(\u0026#39;\u0026#39;.join([m.surface for m in sentence[int(dst)].morphs if m.pos != \u0026#39;記号\u0026#39;])) dst = sentence[int(dst)].dst ed = [\u0026#39;\u0026#39;.join([m.surface for m in sentence[int(dst)].morphs if m.pos != \u0026#39;記号\u0026#39;])] pl.append([st1, st2 + mid, ed]) return pl for sentence in sentence_chunks: pl = convert(sentence) for p in pl: if isinstance(p[0], str): print(\u0026#39;-\u0026gt; \u0026#39;.join(p)) else: print(p[0][0], \u0026#39;-\u0026gt; \u0026#39;.join(p[1]), p[2][0], sep=\u0026#39;| \u0026#39;) 49 についてはタームが理解できなかったのでほぼ写経。コードから意図を汲み取ることが必要。\n","date":"2020-05-11","id":17,"title":"言語処理100本ノック 2020 第5章","url":"/post/100knock_5/"},{"body":"異常な図とは？ 【速報】首相官邸ホームページで三権分立を改竄、国民の上に行政を主権者としてしまうhttps://t.co/TUIlnoBs9W pic.twitter.com/nZyoXalOOk\n\u0026mdash; 𓉤箱コネマン𓁷 (@HAKOCONNEMAN) May 9, 2020  この異常性はGoogle で画像検索をすれば分かる。\nこれは安倍内閣のせいなの？ web archives で見ると1997年からこの矢印が描かれた図を使っているらしい。\nhttps://web.archive.org/web/19971126084116/https://www.kantei.go.jp/jp/rekidai/images/120c.gif\n橋本龍太郎内閣で1996年に官邸ホームページが開設されたわけだが、それ以来ずっと異常な図を掲載してきたと分かる。\n安倍内閣のせいならまだマシ 安倍内閣のせいであればまだマシだ。一時的な病気と見ることが（まだ）可能だからだ。しかしこれは宿痾だ。安倍内閣の異常性とは別に追及すべき事案だと考える。\nこういうことを書くと「途中民主党政権があったじゃないか」という連中がいるが、政権を担当した期間を考えると Web サイトの内容をすべて精査し置き換えるような余裕はないはずだ。いちゃもんに過ぎない。\n","date":"2020-05-10","id":18,"title":"首相官邸の三権分立図は20年来異常だ","url":"/post/prosecution/"},{"body":"記録  月 火 水 木 金 土 日  リンクのない曜日は rest 。毎日トリフェクタは実施している。\n所感 GW のためイレギュラーなもの。今週はストリクトを意識した。\n","date":"2020-05-09","id":19,"title":"2020-05-04 の週のトレーニングノート","url":"/post/training_note_20200504/"},{"body":"記録  月 火 水 木 金 土 日  リンクのない曜日は rest 。毎日トリフェクタは実施している。\n所感 このページを作るのを忘れてた。毎週書かないと忘れる。\n","date":"2020-05-09","id":20,"title":"2020-04-27 の週のトレーニングノート","url":"/post/training_note_20200427/"},{"body":"  言語処理100本ノック 2020 - NLP100 2020\n関連記事: tag 言語処理100本ノック\n所感 コードを書く上で難しいということはあまりないが、門外漢のため問題文に用いられる用語が分からず苦戦した。これらのタームを難なく理解できることもこの課題の狙いだと（勝手に）考えることにする。\n形態素解析には MeCab を使う。解析結果をファイル（neko.txt.mecab）に保存してから扱うので、mecab-python のようなライブラリをインストールする必要はないから導入は楽だと思う。\ncode 今回からは IntelliJ IDEA （+ Python プラグイン）を使った。\n実際には全問を1ファイルで解いているが、本記事ではコメントや図形を挿入するために分割して記述している部分がある。\n#!/usr/local/bin/python3 import pprint path = \u0026#39;/path/to/neko.txt.mecab\u0026#39; # 030 with open(path) as f: s_split = f.read().split(\u0026#39;EOS\\n\u0026#39;) sentences = [] for s in s_split: if s == \u0026#39;\u0026#39;: continue words_list = [] for w in s.split(\u0026#39;\\n\u0026#39;): if w == \u0026#39;\u0026#39;: continue (surface, attr) = w.split(\u0026#39;\\t\u0026#39;) attrs = attr.split(\u0026#39;,\u0026#39;) words_list.append({ \u0026#39;surface\u0026#39;: surface, \u0026#39;base\u0026#39;: attrs[6], \u0026#39;pos\u0026#39;: attrs[0], \u0026#39;pos1\u0026#39;: attrs[1] }) sentences.append(words_list) pprint.pprint(words_list) MeCab の出力フォーマット\n# 031 # リストを均す from itertools import chain flattened = list(chain.from_iterable(sentences)) surface_list = [] for d in flattened: if d[\u0026#39;pos\u0026#39;] == \u0026#39;動詞\u0026#39;: surface_list.append(d[\u0026#39;surface\u0026#39;]) print(surface_list) list の flatten は itertool を使うと良いと公式ドキュメントにあった。 reduce を使ったりしてたが、こっちのほうが早いし楽。\n# 032 内包表記にした print([d[\u0026#39;base\u0026#39;] for d in flattened if d[\u0026#39;pos\u0026#39;] == \u0026#39;動詞\u0026#39;]) # 033 no_list = [] for i in range(len(flattened) - 2): if flattened[i][\u0026#39;pos\u0026#39;] == \u0026#39;名詞\u0026#39; and flattened[i + 1][\u0026#39;surface\u0026#39;] == \u0026#39;の\u0026#39; and flattened[i + 2][\u0026#39;pos\u0026#39;] == \u0026#39;名詞\u0026#39;: no_list.append(flattened[i][\u0026#39;surface\u0026#39;] + \u0026#39;の\u0026#39; + flattened[i + 2][\u0026#39;surface\u0026#39;]) print(no_list) # 034 connection = \u0026#39;\u0026#39; connection_list = [] for d in flattened: if d[\u0026#39;pos\u0026#39;] == \u0026#39;名詞\u0026#39;: connection += d[\u0026#39;surface\u0026#39;] else: if connection != \u0026#39;\u0026#39;: connection_list.append(connection) connection = \u0026#39;\u0026#39; print(connection_list) # 035 from collections import Counter c = Counter([d[\u0026#39;surface\u0026#39;] for d in flattened]) most_common_list = c.most_common() print(most_common_list) 出現回数を数える場合は Counter を使うのが便利で、特に[most_common](https://docs.python.org/ja/3/library/collections.html#collections.Counter.most_common] はタプル (要素, 出現回数) を出現回数順に取得できる。\n# 036 import numpy as np import matplotlib.pyplot as plt from matplotlib import rcParams height = np.array([most_common_list[i][1] for i in range(10)]) left = np.array([most_common_list[i][0] for i in range(10)]) fig = plt.figure() rcParams[\u0026#34;font.family\u0026#34;] = \u0026#39;Hiragino Maru Gothic Pro\u0026#39; plt.bar(left, height) fig.savefig(\u0026#39;036.png\u0026#39;)   Linux だったら IPAex フォントを入れておくのが良いのだろうか。 Mac なのでプリインストールのフォントを使った。\n# 037 cooccurrences = [] for s in sentences: words = [x[\u0026#39;surface\u0026#39;] for x in s] if \u0026#39;猫\u0026#39; in words: cooccurrences.extend([x for x in words if x != \u0026#39;猫\u0026#39;]) c = Counter(cooccurrences) most_common_list_cat = c.most_common() height = np.array([most_common_list_cat[i][1] for i in range(10)]) left = np.array([most_common_list_cat[i][0] for i in range(10)]) fig = plt.figure() rcParams[\u0026#34;font.family\u0026#34;] = \u0026#39;Hiragino Maru Gothic Pro\u0026#39; plt.bar(left, height) fig.savefig(\u0026#39;037.png\u0026#39;)   「猫」と同じ文中に現れる回数を計算すればよいだろうか。きれいに書こうとしなければ簡単。\n# 038 fig = plt.figure() plt.hist([x[1] for x in most_common_list], bins=20, range=(1, 100)) fig.savefig(\u0026#39;038.png\u0026#39;)   035 の結果を使う。表示する頻度を全体にすると可視化の意味がなくなるので100位程度までに絞る。\n# 039 fig = plt.figure() plt.scatter([i+1 for i in range(len(most_common_list))], [x[1] for x in most_common_list]) plt.xscale(\u0026#39;log\u0026#39;) plt.yscale(\u0026#39;log\u0026#39;) fig.savefig(\u0026#39;039.png\u0026#39;)   ","date":"2020-05-03","id":21,"title":"言語処理100本ノック 2020 第4章","url":"/post/100knock_4/"},{"body":"  言語処理100本ノック 2020 - NLP100 2020\n関連記事: tag 言語処理100本ノック\ncode target_dir = \u0026#39;/users/tbsmcd/Documents/\u0026#39; file_path = target_dir + \u0026#39;jawiki-country.json.gz\u0026#39; # 020 import json, pprint, gzip data = [] with gzip.open(file_path, \u0026#39;r\u0026#39;) as f: for line in f: article = json.loads(line) if article[\u0026#39;title\u0026#39;] == \u0026#39;イギリス\u0026#39;: uk = article[\u0026#39;text\u0026#39;] break pprint.pprint(uk) gzip モジュールは知らなかった。\n#021 import re pattern = re.compile(r\u0026#39;(\\[\\[Category:.*\\]\\])\u0026#39;, re.MULTILINE) res = pattern.findall(uk) for line in res: print(line) re.MULTILINE(re.M) などのオプションを忘れている。\n#022 import re pattern = re.compile(r\u0026#39;\\[\\[Category:(.*)\\]\\]\u0026#39;, re.MULTILINE) res = pattern.findall(uk) for line in res: print(line) シンプル\n# 023 # セクション？ # ref. https://ja.wikipedia.org/wiki/Help:%E3%82%BB%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3#%E3%82%BB%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E4%BD%9C%E6%88%90%E3%81%A8%E7%95%AA%E5%8F%B7%E4%BB%98%E3%81%91 pattern = re.compile(r\u0026#39;=(=+)(.+?)=\u0026#39;, re.MULTILINE) res = pattern.findall(uk) for line in res: print(line[1], len(line[0])) 貪欲マッチの ? とかすぐに出てこなくて焦る\n# 024 pattern = re.compile(r\u0026#39;ファイル:(.+?)\\|\u0026#39;, re.MULTILINE) res = pattern.findall(uk) for line in res: print(line) # 025 pattern = re.compile(r\u0026#39;\u0026#39;\u0026#39;^\\{\\{基礎情報.*?$.*?^\\}\\}$\u0026#39;\u0026#39;\u0026#39;, re.MULTILINE+re.DOTALL) data = \u0026#39;\\n\u0026#39;.join(pattern.findall(uk)) pattern = re.compile(r\u0026#39;^\\|(.+?)\\s*=\\s*(.+?)$\u0026#39;, re.MULTILINE) res = {} for t in pattern.findall(data): res[t[0]] = t[1].replace(\u0026#34;\\n\u0026#34;, \u0026#39;\u0026#39;) memo: re.DOTALL\n# 026 def strip_markup(text): pattern = re.compile(r\u0026#39;(\\\u0026#39;{2,5})(.+?)(\\1)\u0026#39;, re.M) return pattern.sub(r\u0026#39;\\2\u0026#39;, text) pattern = re.compile(r\u0026#39;\u0026#39;\u0026#39;^\\{\\{基礎情報.*?$.*?^\\}\\}$\u0026#39;\u0026#39;\u0026#39;, re.MULTILINE+re.DOTALL) data = \u0026#39;\\n\u0026#39;.join(pattern.findall(uk)) pattern = re.compile(r\u0026#39;^\\|(.+?)\\s*=\\s*(.+?)$\u0026#39;, re.MULTILINE) res = {} for t in pattern.findall(data): res[t[0]] = strip_markup(t[1].replace(\u0026#34;\\n\u0026#34;, \u0026#39;\u0026#39;)) print(res) \\1 を知らなかった。またコンパイル済みの pattern.sub() で pattern の /2 が使えるのも当然知らなかった。\n# 027 def strip_markup(text): pattern = re.compile(r\u0026#39;(\\\u0026#39;{2,5})(.+?)(\\1)\u0026#39;, re.M) text = pattern.sub(r\u0026#39;\\2\u0026#39;, text) pattern = re.compile(r\u0026#39;\\[\\[([^\\|]*?)\\]\\]\u0026#39;) text = pattern.sub(r\u0026#39;\\1\u0026#39;, text) pattern = re.compile(r\u0026#39;\\[\\[(.+?)\\|(.+?)\\]\\]\u0026#39;) return pattern.sub(r\u0026#39;\\2\u0026#39;, text) pattern = re.compile(r\u0026#39;\u0026#39;\u0026#39;^\\{\\{基礎情報.*?$.*?^\\}\\}$\u0026#39;\u0026#39;\u0026#39;, re.MULTILINE+re.DOTALL) data = \u0026#39;\\n\u0026#39;.join(pattern.findall(uk)) pattern = re.compile(r\u0026#39;^\\|(.+?)\\s*=\\s*(.+?)$\u0026#39;, re.MULTILINE) res = {} for t in pattern.findall(data): res[t[0]] = strip_markup(t[1].replace(\u0026#34;\\n\u0026#34;, \u0026#39;\u0026#39;)) print(res) # 028 def strip_markup(text): pattern = re.compile(r\u0026#39;(\\\u0026#39;{2,5})(.+?)(\\1)\u0026#39;, re.M) text = pattern.sub(r\u0026#39;\\2\u0026#39;, text) pattern = re.compile(r\u0026#39;\\[\\[([^\\|]*?)\\]\\]\u0026#39;) text = pattern.sub(r\u0026#39;\\1\u0026#39;, text) pattern = re.compile(r\u0026#39;\\[\\[(.+?)\\|(.+?)\\]\\]\u0026#39;) text = pattern.sub(r\u0026#39;\\2\u0026#39;, text) pattern = re.compile(r\u0026#39;\\{\\{lang\\|[^\\|]+?\\|([^\\|]+)\\}\\}\u0026#39;) text = pattern.sub(r\u0026#39;\\1\u0026#39;, text) # あとの除去は省略 return text pattern = re.compile(r\u0026#39;\u0026#39;\u0026#39;^\\{\\{基礎情報.*?$.*?^\\}\\}$\u0026#39;\u0026#39;\u0026#39;, re.MULTILINE+re.DOTALL) data = \u0026#39;\\n\u0026#39;.join(pattern.findall(uk)) pattern = re.compile(r\u0026#39;^\\|(.+?)\\s*=\\s*(.+?)$\u0026#39;, re.MULTILINE) res = {} for t in pattern.findall(data): res[t[0]] = strip_markup(t[1].replace(\u0026#34;\\n\u0026#34;, \u0026#39;\u0026#39;)) print(res) # 029 import sys import pprint import urllib.parse, urllib.request pattern = re.compile(r\u0026#39;\u0026#39;\u0026#39;^\\{\\{基礎情報.*?$.*?^\\}\\}$\u0026#39;\u0026#39;\u0026#39;, re.MULTILINE+re.DOTALL) data = \u0026#39;\\n\u0026#39;.join(pattern.findall(uk)) pattern = re.compile(r\u0026#39;^\\|(.+?)\\s*=\\s*(.+?)$\u0026#39;, re.MULTILINE) res = {} for t in pattern.findall(data): res[t[0]] = strip_markup(t[1].replace(\u0026#34;\\n\u0026#34;, \u0026#39;\u0026#39;)) file_name = res[\u0026#39;国旗画像\u0026#39;] url = \u0026#39;https://www.mediawiki.org/w/api.php?\u0026#39; \\ + \u0026#39;action=query\u0026#39; \\ + \u0026#39;\u0026amp;titles=File:\u0026#39; + urllib.parse.quote(file_name) \\ + \u0026#39;\u0026amp;format=json\u0026#39; \\ + \u0026#39;\u0026amp;prop=imageinfo\u0026#39; \\ + \u0026#39;\u0026amp;iiprop=url\u0026#39; request = urllib.request.Request(url) connection = urllib.request.urlopen(request) data = json.loads(connection.read().decode()) print(data[\u0026#39;query\u0026#39;][\u0026#39;pages\u0026#39;].popitem()[1][\u0026#39;imageinfo\u0026#39;][0][\u0026#39;url\u0026#39;]) あえて標準のライブラリでやったけど、たぶん requests を使ったら圧倒的に楽\n","date":"2020-04-29","id":22,"title":"言語処理100本ノック 2020 第3章","url":"/post/100knock_3/"},{"body":"閑話 筋トレをすれば「上司も葬れると思えて心に余裕が生まれる」という話が何年か前に流行ったが、それなら空手でも習ったほうがより直接的だし、違法な暴力を肯定することが前提なら鈍器でも刃物でも否定できないのではないかと思っている。過去にいじめ・虐待・日常的な暴力を受けていた人が筋トレで自信をつけるのは否定しないが、自分が身体を鍛える上で考えることとは大きく違っている。確かにあのような言葉が大衆に受けるのは理解できる。しかし言葉を面白がるだけではなく本当に鍛えてみたらまた違うのではないかと思う。\n記録  月 火 水 木 金 土 日  リンクのない曜日は rest 。毎日トリフェクタは実施している。\n所感 回数（rep 数）を増やして追い込んで行っている。ワンレッグ系のスクワットは柔軟性とバランスに問題があり、手で補助しながら進めている。ツイストで左臀部が痛むことはなくなってきた。\n","date":"2020-04-27","id":23,"title":"2020-04-20 の週のトレーニングノート","url":"/post/training_note_20200420/"},{"body":"  言語処理100本ノック 2020 - NLP100 2020\n関連記事: tag 言語処理100本ノック\ncode .\n.\n.\n.\n.\n.\n# 準備 target_dir = \u0026#39;/users/tbsmcd/Documents/\u0026#39; file_path = target_dir + \u0026#39;popular-names.txt\u0026#39; # 010 with open(file_path) as f: for i, r in enumerate(f, 1): # 最初のキーを1として取得（デフォルトは0） pass print(i) # wc popular-names.txt  # 2780 11120 55026 popular-names.txt # 011 res = \u0026#39;\u0026#39; with open(file_path) as f: for row in f: res += row.replace(\u0026#34;\\t\u0026#34;, \u0026#34;\u0026#34;) print(res) #cat popular-names.txt | tr \u0026#39;\\t\u0026#39; \u0026#39; \u0026#39; # 012 col1 = [] col2 = [] with open(file_path) as f: for row in f: cols = row.split(\u0026#34;\\t\u0026#34;) col1.append(cols[0]) col2.append(cols[1]) with open(target_dir + \u0026#39;col1.txt\u0026#39;, mode=\u0026#39;w\u0026#39;) as f: f.write(\u0026#39;\\n\u0026#39;.join(col1) + \u0026#39;\\n\u0026#39;) with open(target_dir + \u0026#39;col2.txt\u0026#39;, mode=\u0026#39;w\u0026#39;) as f: f.write(\u0026#39;\\n\u0026#39;.join(col2) + \u0026#39;\\n\u0026#39;) # cut -f 1 ./popular-names.txt # cut -f 2 ./popular-names.txt # 013 col1 = [] col2 = [] with open(target_dir + \u0026#39;col1.txt\u0026#39;) as f: for row in f: col1.append(row.strip()) with open(target_dir + \u0026#39;col2.txt\u0026#39;) as f: for row in f: col2.append(row.strip()) cols = [] for c1, c2 in zip(col1, col2): cols.append(c1 + \u0026#39;\\t\u0026#39; + c2) with open(target_dir + \u0026#39;col1+2.txt\u0026#39;, mode=\u0026#39;w\u0026#39;) as f: f.write(\u0026#39;\\n\u0026#39;.join(cols)) # paste col1.txt col2.txt paste コマンド超便利\n# 014 import argparse parser = argparse.ArgumentParser(description=\u0026#39;先頭からN行を出力する\u0026#39;) parser.add_argument(\u0026#39;lines\u0026#39;, help=\u0026#39;出力したい行数\u0026#39;) args = parser.parse_args(args=[\u0026#39;5\u0026#39;]) with open(file_path) as f: text = f.read() print(\u0026#39;\\n\u0026#39;.join(text.split(\u0026#39;\\n\u0026#39;)[0:int(args.lines)])) # head -n 5 popular-names.txt Jupyter を使っているため parser.parse_args() にはあらかじめ引数を与えておく。実際にコマンドとして使う際には空にする。\n# 015 import argparse parser = argparse.ArgumentParser(description=\u0026#39;末尾からN行を出力する\u0026#39;) parser.add_argument(\u0026#39;lines\u0026#39;, help=\u0026#39;出力したい行数\u0026#39;) args = parser.parse_args(args=[\u0026#39;5\u0026#39;]) with open(file_path) as f: text = f.read().strip() print(\u0026#39;\\n\u0026#39;.join(text.split(\u0026#39;\\n\u0026#39;)[-int(args.lines):])) # tail -n 5 popular-names.txt strip() が無いと最終行のあとの改行文字でも分割され、空の要素が生まれる。\n# 016 import argparse import math parser = argparse.ArgumentParser(description=\u0026#39;末尾からN行を出力する\u0026#39;) parser.add_argument(\u0026#39;split\u0026#39;, help=\u0026#39;分割したい個数\u0026#39;) args = parser.parse_args(args=[\u0026#39;5\u0026#39;]) step = int(args.split) with open(file_path) as f: rows = f.read().strip().split(\u0026#39;\\n\u0026#39;) row_num = math.ceil(len(rows) / step) splited = [rows[i:i + row_num] for i in range(0, row_num, step)] # あとは join で文字列にするだけ # split -n 5 popular-names.txt # mac だと使えないオプションが違う range() の第3引数の step 個飛ばしでループさせているだけ。split コマンドの -n は mac のデフォルトだと使えない。\n# 017 with open(file_path) as f: rows = f.read().strip().split(\u0026#39;\\n\u0026#39;) set([r.split(\u0026#39;\\t\u0026#39;)[0] for r in rows]) # cut -f 1 popular-names.txt | sort | uniq Python 側もだいぶ短いコードで実現できる。\n# 018 with open(file_path) as f: rows = f.read().strip().split(\u0026#39;\\n\u0026#39;) sorted(rows, key=lambda x: int(x.split(\u0026#39;\\t\u0026#39;)[2])*-1) # あとは join などで…… # sort -brn -k 3 popular-names.txt 文字列連結部分は繰り返しなので省略している。\n# 019 with open(file_path) as f: rows = f.read().strip().split(\u0026#39;\\n\u0026#39;) names = [r.split(\u0026#39;\\t\u0026#39;)[0] for r in rows] names_dic = {} for n in set(names): names_dic[n] = names.count(n) sorted(names_dic.items(), key=lambda x: x[1], reverse=True) # cut -f 1 popular-names.txt | sort | uniq -c | sort -brn -k 1 items() を使えばタプルとして取得できる（x[1]）のをよく忘れる。\n","date":"2020-04-26","id":24,"title":"言語処理100本ノック 2020 第2章","url":"/post/100knock_2/"},{"body":"  言語処理100本ノック 2020 - NLP100 2020\n関連記事: tag 言語処理100本ノック\nなぜ？ 最近 Python を書いてないこともあり、思うところもあり。\n環境 Python3 + Anaconda + Jupyter Notebook\nインストール等については気が向いた時に。\ncode 以下ネタバレ\n.\n.\n.\n.\n.\n.\n.\n.\n.\nまず第1章から\n# 000 st = \u0026#39;stressed\u0026#39; ans = \u0026#39;\u0026#39; for i in range(len(st)): ans += st[-i - 1] print(ans) # 000 st = \u0026#39;stressed\u0026#39; print(st[::-1]) # [start:stop:step] start = 0 つまり1文字目の前から # 001 st = \u0026#39;パタトクカシーー\u0026#39; print(st[0] + st[2] + st[4] + st[6]) # 001 st = \u0026#39;パタトクカシーー\u0026#39; print(st[::2]) # 000 と同様 ## 002 pc = \u0026#39;パトカー\u0026#39; tx = \u0026#39;タクシー\u0026#39; print(\u0026#39;\u0026#39;.join([p + t for p, t in zip(pc, tx)])) # zip : 複数の list の要素をまとめて読む, 内包表記のことを忘れている # 003 txt = \u0026#39;Now I need a drink, alcoholic of course, after the heavy lectures involving quantum mechanics.\u0026#39; words = txt.replace(\u0026#39;,\u0026#39;, \u0026#39;\u0026#39;).replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;).split() [len(word) for word in words] # 004 txt = \u0026#39;Hi He Lied Because Boron Could Not Oxidize Fluorine. New Nations Might Also Sign Peace Security Clause. Arthur King Can.\u0026#39; words = txt.replace(\u0026#39;.\u0026#39;, \u0026#39;\u0026#39;).split() target = [1, 5, 6, 7, 8, 9, 15, 16, 19] res = {} i = 1 for i, w in enumerate(words): # enumerate 忘れる if (i + 1 in target): res[w[0:1]] = i + 1 else: res[w[0:2]] = i + 1 res # 005 def n_gram(target, n): # スライスは文字列でもリストでも出来る return [target[i:i + n] for i in range(len(target) - n + 1)] target = \u0026#39;I am an NLPer\u0026#39; # 文字 bi-gram print(n_gram(target, 2)) # 単語 bi-gram print(n_gram(target.split(\u0026#39;\u0026#39;), 2)) # 006 def n_gram(target, n): return set([target[i:i + n] for i in range(len(target) - n + 1)]) X = n_gram(\u0026#39;paraparaparadise\u0026#39;, 2) Y = n_gram(\u0026#39;paragraph\u0026#39;, 2) # 和集合 print(X | Y) # 積集合 print(X \u0026amp; Y) # 差集合 print(X - Y) # 存在確認 print(\u0026#39;se\u0026#39; in X) print(\u0026#39;se\u0026#39; in Y) # 007 def sent(x, y, z): return(str(x) + \u0026#39;時の\u0026#39; + str(y) + \u0026#39;は\u0026#39; + str(z)) print(sent(12, \u0026#39;気温\u0026#39;, 22.4)) # 008 def cr(st): res = \u0026#39;\u0026#39; for s in list(st): if s.isalpha and s.islower res += chr(219 - ord(s)) else: res += s return res code = cr(\u0026#34;I\u0026#39;m happy.\u0026#34;) string = cr(code) print(code) print(string) ## 009 import random def make_rand(s): if len(s) \u0026lt;= 4: return s else: li = list(s) first = li.pop(0) last = li.pop(-1) random.shuffle(li) return first + \u0026#39;\u0026#39;.join(li) + last text = \u0026#39;I couldn’t believe that I could actually understand what I was reading : the phenomenal power of the human mind .\u0026#39; res = \u0026#39;\u0026#39; for w in text.split(\u0026#39;\u0026#39;): res += make_rand(w) print(res) 最初の方はスライスなどを思い出すために複数パターン書いてみたが、あとの方では飽きてる。\n","date":"2020-04-24","id":25,"title":"言語処理100本ノック2020 を始めた 第1章","url":"/post/100knock_1/"},{"body":"記録  月 火 水 水 金 土 日  リンクのない曜日は rest 。毎日トリフェクタは実施している。\n所感 今週は決めたレップ数をこなすことに充てた。しかしそれでは成長しないので、ストリクトなフォームを維持できる範囲で1レップでも増やす。\n04-18 土 ふだんツイストをすると左の小臀筋か中臀筋が痛む。長時間歩いても痛みが出ることがあるので何らかの問題があることは確か。しかし今日は痛みがかなり小さい。日中散歩を2時間程度しかからか？\nウォーキングで動かしたことで伸びやすくなったかもしれない。最近ツイスト動作を行っているからかもしれない。両方かも。 またはツイストにより歩き方に改善が見られた事も考えられる。\n04-19 日 歩かずにツイストをすると少し痛みが戻ってる。\n","date":"2020-04-19","id":26,"title":"2020-04-13 の週のトレーニングノート","url":"/post/training_note_20200413/"},{"body":"2020-04-06  フル・プッシュアップ  プッシュアップ STEP 5 15レップ2セット  中級者の標準 = 10*2   昼食後    2セット目は2秒の伸長を守れなかったかもしれない。手幅も追求したい。書籍の図より幅を広めにとった方が「入る」感覚がある。筋肥大用にアレンジをしても良さそう。\n フラット・ストレート・レッグレイズ  レッグレイズ STEP 5 15レップ2セット  = 中級者の標準   就業後    ハムストの柔軟性の問題で若干の抵抗があるものの、フォームを崩さず行うことは可能である。\n2020-04-09  フル・ブリッジ  ブリッジ STEP 6 10レップ2セット  = 中級者の標準   就業後    肩や大腿四頭筋に疲労感がある。背面をもう少し使いたい。脊柱には程よい疲労感。\n ローボード・ジャックナイフ・プッシュアップ  番外編/ハンドスタンド・プッシュアップ STEP 5 の準備段階 10レップ2セット 夕食後    壁に椅子を押し付けて固定したほうが良い。\n レスラーブリッジ  首の補強 20秒2セット    起立筋の奥の方にあるふだん動かせていない筋肉を動かすのは、現下の在宅勤務情勢に適しているのではないか？\n2020-04-11  フル・スクワット  スクワット STEP 5 30レップ1セット  上級者の標準 = 30レップ2セット     クローズド・スクワット  スクワット STEP 6 20レップ1セット  上級者の標準 = 20レップ2セット      フルスクワットの強度が足りなかったので途中で STEP を調整した。\n ハーフ・プルアップ  プルアップ STEP 4 10レップ2セット  中級者の標準 = 11レップ2セット      収縮位での1秒静止が思いの外厳しい。着実に進んでいきたい。\n","date":"2020-04-11","id":27,"title":"2020-04-05 の週のトレーニングノート","url":"/post/training_note_20200405/"},{"body":"この記事は書籍に載っている具体的なトレーニング方法を載せるものではない。ググってみたら種目をそのまま載せているような記事も見受けられるが、褒められたものではないと思う。\nジムには行けない 「躊躇なく」と言っていたと言っていたはずの緊急事態宣言は、躊躇の痕跡を我々に見せながら予告された。宣言の宣言。そんな情況とはあまり関係なく主体的にリスクを考えた結果、数週間ジムに行っていない。これを機に以前より気になっていた「プリズナートレーニング」を試してみたいと考えた。まず以下の3冊を読んだ。\n     どういったトレーニングなのか プリズナートレーニング。刺激的な名前と、表紙に描かれたビスケット・オリバのせいでハードコアな印象を受ける。実際にはどうだろうか？\n rep: ストリクトに、フォームを崩さず、1rep ずつを丁寧に。2秒伸長→1秒キープ→2秒収縮→1秒キープ。 set: 2セット程度まで。やりすぎは良くない routine: 「善行」は1日に2種目、週に3日行う step up: 時間をかける、「飛び級」しない、腱や関節に無理をさせない  ずいぶん印象と違うはずだ。\nフリーウェイトとの対比でいえば、例えばベンチプレスよりプッシュアップの方が体幹を使うので、上半身を連携した運動になっている。一事が万事、こういう広範囲な連携を重視しているように思う。\nスロトレ？ 時間をかけ収縮伸長するのはスロトレでは？という人もあるだろう。たぶん基本的には近い。ただしスロトレは3-4秒かけ収縮、ロックせずすぐに3-4秒かけて伸長するものなので、厳密には違う（石井直方『石井直方のトレーニングのヒント』ベースボール・マガジン社）。プリズナートレーニングの方が負荷を大きくする傾向にあると思う。\n背中はどう鍛えるのか？ 基本は鉄棒。公園を彷徨えば、何とか懸垂可能な鉄棒は見つかるはずだ。ただし通報されないよう気をつけよう。\n 公園が無理でも、いまどきは強度に問題のないプルアップ・スタンドが1万円程度で買える。おれも買おうかと考えている。\n筋肥大は狙えるのか？ 番外編が応えていると思う。丁寧な1 rep を、というのが基本なので、中級者までは THE BIG SIX をストリクトに行うのが良さそう。鉄棒で上腕を鍛える方法はなかなか得られない知見だと思う。\n実践してみて まだろくに行っていないが、種目によっては STEP 5 あたりを中級者の標準で行える（本書では初級・中級・上級の標準を reps, sets によって示している）。いきなり「飛び級」をするのは推奨されていないが（上述の通り、時間をかけて進むことが推奨される）、トレーニング経験があれば多少のステップアップは許されるだろう。体感では、ストリクトに行えばジムで得られる「入る感覚」も得ることが出来る。これはジムで指導を受けた経験が生きてるはずだ。\n本書ではトレーニング記録を推奨しているので、 Scrapbox をメモとし、本ブログ上にて公開していく。\n","date":"2020-04-06","id":28,"title":"プリズナートレーニングに入門した","url":"/post/calisthenics/"},{"body":"何ら新規性はないが作業記録として。\nWebIOPi のインストール WebIOPi はラズパイ上の GPIO 、センサ、コンバータなどを Web ブラウザや他のアプリから操作するためのライブラリ（Control, debug, and use your Pi's GPIO, sensors and converters from a web browser or any app）。REST API を用意しているから他のアプリからでも操作できるということだろう。\n  The Raspberry Pi Internet of Things Toolkit - Now in two flavors より\n今回は GPIO を用いないが、 Python のスクリプトを実行できる手軽な環境ということで使うことにした。『カラー図解 最新 Raspberry Pi で学ぶ電子工作 作って動かしてしくみがわかる（ブルーバックス）』でも使い方が書かれているし、デファクト・スタンダードなのだろう。しかし最終バージョンが2015年なので現在の Raspbian で動かすにはパッチを当てる必要がある。\n# ダウンロード $ wget https://sourceforge.net/projects/webiopi/files/WebIOPi-0.7.1.tar.gz $ tar zxvf WebIOPi-0.7.1.tar.gz # パッチをあてる $ cd WebIOPi-0.7.1/ $ wget https://raw.githubusercontent.com/doublebind/raspi/master/webiopi-pi2bplus.patch $ patch -p1 -i webiopi-pi2bplus.patch # インストール $ sudo ./setup.sh # 今回は家庭内で使うから n # y の場合は Weaved IoT Kit がインストールされ、外部ネットワークから利用可能に出来る Do you want to access WebIOPi over Internet ? [y/n] n # systemctl のための設定 $ cd /etc/systemd/system/ $ sudo wget https://raw.githubusercontent.com/doublebind/raspi/master/webiopi.service # 起動 $ sudo systemctl start webiopi http://[ホスト名]:8000 でアクセスし、ユーザ名 webiopi パスワード raspberry で動作を確認出来る。\n実際にスクリプトを書く ファイル配置は以下の通り\npi@rp0:~ $ tree webiopi/ webiopi/ ├── index.html ├── main.js └── scripts └── noise.py 今回は子供の安眠のためのピンクノイズ発生機能を簡易ベビーモニターに追加したいので noise.py となっているが、各自好きにしたらよいだろう。\n作業ディレクトリの追加 $ mkdir webiopi WebIOPi の設定 $ cd /etc/webiopi/ $ sudo vim config # 以下編集内容 # Use doc-root to change default HTML and resource files location #doc-root = /home/pi/webiopi/examples/scripts/macros doc-root = /home/pi/webiopi/ # each sourcefile may have setup, loop and destroy functions and macros #myscript = /home/pi/webiopi/examples/scripts/macros/script.py myscript = /home/pi/webiopi/scripts/noise.py doc-root は html を配置するドキュメントルート、myscript は実際に動作させる Python スクリプトの path。\nindex.html \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Noise\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/webiopi.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;http://rp0.local:8080/?action=stream\u0026#34; style=\u0026#34;width:100%\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Start\u0026#34; class=\u0026#34;python\u0026#34; onClick=\u0026#34;start()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;Stop\u0026#34; class=\u0026#34;python\u0026#34; onClick=\u0026#34;stop()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; onClick で main.js の関数を呼ぶ。\nmain.js webiopi() function start() { webiopi().callMacro(\u0026#39;start\u0026#39;); } function stop() { webiopi().callMacro(\u0026#39;stop\u0026#39;); } 各関数が Python の関数（マクロ関数）を呼ぶだけのシンプルなもの。webiopi().callMacro('マクロ関数名', '引数', 'コールバック関数名') という引数を取るが、今回は引数とコールバックを省略した。\nnoise.py import webiopi import subprocess @webiopi.macro def start(): subprocess.run(\u0026#39;pgrep -f play | xargs kill \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\u0026#39;, shell=True) subprocess.Popen(\u0026#39;play -n synth pinknoise \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\u0026#39;, shell=True) @webiopi.macro def stop(): subprocess.run(\u0026#39;pgrep -f play | xargs kill \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\u0026#39;, shell=True) Python3 で書く必要がある。とりあえずピンクノイズの発生については Python がコマンドの終了を待つ必要がないので Popen を使った。@webiopi デコレータはブラウザから実行可能にするために必要である。\nplay コマンドは Linux で音声の加工をするための Sox をインストールしたら使える。インストールコマンドは\n$ sudo apt install sox 実際の画面  今後 これでブラウザから子供の睡眠環境の管理がより進むことになる。たとえば温湿度センサから値を取得しブラウザに表示するなども良いだろうし、反町隆史アイコンをタップしたら POISON が流れても良いと思う。\nref. 反町「POISON」赤ちゃん泣き止む説　ＴＶ特集され反応「すごい」「POISONマジかよ」\nいや、我が娘は泣いてる時に POISON 聴かせるとマジで泣き止むし、寝るからな。敬意を込めて「タカシ」と呼ぶことにしてる。\n閑話休題、 Web で UI を作るのは慣れたことだし Python が動けば割合なんでも出来るので、ラズパイを使う上で自由度は上がると思う。\n","date":"2020-03-29","id":29,"title":"WebIOPi を使い Web ブラウザから Raspberry Pi 上で Python を実行する","url":"/post/webiopi_python/"},{"body":"前提 セットアップはこちらから。\n要件 0歳児は夜寝るのが早い。だいたい20時には寝ているが、親である我々はそんなに早く寝ることが出来ない。なので子供が寝ている暗い部屋の隣の明るい部屋で夕食を食っていたりするのだけど、最近寝返りをしてそのままうつ伏せで寝ることがあり、それはとても危険なので監視している必要がある（最悪死ぬ）。しかし部屋の仕切りを開放すると寝室が明るくなり眠りが浅くなるので、なるべく暗いままで監視がしたい。これは早めに解決したい課題なので、以下の最低限の機能を実現する（完成品買えば？）。\n 暗視カメラとして使用できる スマートフォン・PC から確認できる  カメラモジュール    Raspberry Pi に差し込めばすぐに使える。しかし冷静に考えたら高いな……（完成品買えば？）\nmjpg-streamer のインストール カメラの画像（静止画・動画）をストリーミング配信するツール。\n$ sudo apt-get -y cmake libv4l-dev libjpeg-dev imagemagick $ git clone https://github.com/jacksonliam/mjpg-streamer.git mjpg-streamer $ cd mjpg-streamer/mjpg-streamer-experimental $ make mjpg-streamer の起動 $ cd ~/mjpg-streamer/mjpg-streamer-experimental $ ./mjpg_streamer -o \u0026#34;./output_http.so -w ./www\u0026#34; -i \u0026#34;./input_raspicam.so -x 640 -y 480 -fps 30 -q 10\u0026#34; Raspberry Pi を起動するたびにこのコマンドを打っていても仕方ないので、/etc/rc.local の最終行 exit 0 の前に雑なコマンドを書いて起動時に実行されるようにしている。\ncd /home/pi/mjpg-streamer/mjpg-streamer-experimental/ \u0026amp;\u0026amp; ./mjpg_streamer -o \u0026#34;./output_http.so -w ./www\u0026#34; -i \u0026#34;./input_raspicam.so -x 640 -y 480 -fps 30 -q 10\u0026#34; ケースを作成 現代家庭生活であり余る資材とは段ボールのことだ。なのでこうなる。\n 一応天地の板は段ボールを90度ズラした状態で二重にしてある。排熱も必要だろうから密閉はしていない。\n光源 赤外線カメラなので赤外線を照射する必要がある。Amazon で適当に買った。強い赤外線を見つめ続けると白内障になる恐れがあるようで、たぶん神経質になるほどのものではないが、いちおう部屋の天井に向かって照射し、部屋全体に拡散するようにしている。\nブラウザからアクセス http://[ホスト名]:8080/?action=stream\n なお http://[ホスト名]:8080 にアクセスしたらその機能の全容は分かる。\n展望 せっかく寝室にラズパイを置くので、他に使いみちがあると思っている。例えば子供の安眠のためにホワイトノイズを流しているときにインターフォンに気付かないことがあるので、インターフォンを監視しているラズパイから通知が来たら寝室のラズパイがランプを光らせるとか（スマートフォンに通知すれば良いのだけど、寝かしつけ中は案外気付けない）、ありがちだけど環境監視とか。\n以下に書いていくことにする。\nラズパイでやりたいこと - tbsmcd のいろいろ\n","date":"2020-03-20","id":30,"title":"簡易ベビーモニター（赤外線対応）を Raspberry Pi で作った（ノーコード・ノー工具）","url":"/post/baby_monitor/"},{"body":"前提 作業環境は macOS Mojave\n本体は Raspberry Pi 3 model B\n➤ で始まるのは mac のターミナル、 $ で始めるのは Raspberry Pi のターミナル\n買ったもの 本体とストレージ      電源周り     USB 接続のキーボード、マウスなどは家に転がっているもので良い。\nOS(Raspbian) ダウンロード Download Raspbian for Raspberry Pi に3種類あり、大（デスクトップ環境に LibreOffice や多くの開発環境などいろいろ入ってる）中（デスクトップの環境……ブラウザや多少の開発環境がある）小（CUI）という感じ。今回は中（Raspbian Buster with desktop）を選んだ。ただしここから直接ダウンロードすると数時間かかるようだったので、国内のミラーからダウンロードした。\nRaspbianMirrors - Raspbian\n今回は JAIST を選択。\nmicroSD の準備 公式ドキュメントを参考に。\nフォーマット microSD を接続しターミナルで diskutil list\n➤ diskutil list /dev/disk0 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 251.0 GB disk0 1: EFI EFI 314.6 MB disk0s1 2: Apple_APFS Container disk1 250.7 GB disk0s2 /dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.7 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 73.7 GB disk1s1 2: APFS Volume Preboot 45.5 MB disk1s2 3: APFS Volume Recovery 510.4 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4 /dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *31.9 GB disk2 1: Windows_FAT_32 NO NAME 31.9 GB disk2s1 /dev/disk2 が microSD なので、新品なら多くの場合 FAT-32 になっているのでフォーマットの必要はないと思う（/dev/disk2 部分は、他のメディアを接続していたりすると変わる）。もしフォーマットする場合は以下の通り。\n➤ diskutil eraseDisk MS-DOS RP0 /dev/disk2 Started erase on disk2 Unmounting disk Creating the partition map Waiting for partitions to activate Formatting disk2s2 as MS-DOS (FAT) with name RP0 512 bytes per physical sector /dev/rdisk2s2: 61891008 sectors in 1934094 FAT32 clusters (16384 bytes/cluster) bps=512 spc=32 res=32 nft=2 mid=0xf8 spt=32 hds=255 hid=411648 drv=0x80 bsec=61921280 bspf=15111 rdcl=2 infs=1 bkbs=6 Mounting disk Finished erase on disk2 RP0 は自分で設定したデバイス名なので、任意で良い。\nイメージの書き込み microSD をアンマウントし、\n➤ diskutil umountDisk /dev/disk2 Unmount of all volumes on disk2 was successful ダウンロードしたイメージを書き込む（path は個々人の環境による）。\n➤ sudo dd bs=1m if=/path/to/2020-02-13-raspbian-buster.img of=/dev/rdisk2 conv=sync of=/dev/disk2 とした場合はバッファを通して書き込むのに対し、/dev/disk2 とした場合はバッファを通さないので早い（はず）。\neject はデスクトップから行った。\n本体を起動 イメージを書き込んだ microSD を Raspberry Pi に挿入し、電源用の Micro USB を挿せば起動する。ディスプレイ・キーボード・マウスも接続しておく。いまどきの Raspbian は設定ウィザードが充実しているので、求められる通りに設定していけば Wi-Fi の設定まで完了する。楽すぎる……\nSSH 接続 SSH 有効化 キーボードは接続したものの、ふだんから慣れているデバイスで操作したいというのが人類の性。なので SSH 接続できるようにする。 といっても、メニュー \u0026gt; 設定 \u0026gt; Raspberry Pi の設定 から\n とすれば有効になる。簡単。\nホスト名で接続 ついでにホスト名で接続したいので、まずはファイル編集用に Vim をインストール。Raspberry Pi のターミナルで\n$ sudo apt-get update $ sudo apt-get install vim /etc/hostname の編集\n$ sudo vim /etc/hostname rp0.local とする（rp0 は任意のホスト名に変更）。\n/etc/hosts の編集\n$ sudo vim /etc/hosts 127.0.1.1\trp0 を追加で書き込む(rp0は以下略)。\n一旦再起動したら、 mac のターミナルから\n➤ ssh pi@rp0.local とすればログインできる（rp0は）。\nリモートデスクトップの設定 Raspberry Pi に VNC サーバをインストール ここから追記 2020-03-20\n公式ドキュメント には RealVNC での接続方法が掲載されている。\nrealvnc-vnc-server のインストール\n$ sudo apt install realvnc-vnc-server インストールが完了すると、デスクトップのメニュー \u0026gt; 設定 \u0026gt; Raspberry Pi の設定 で VNC を有効にできる。未インストール状態ではラジオボタンが選択不可になる。\n macOS 側では VNC Viewer をインストールする必要がある。インストール後起動し、 IP アドレスかホスト名を入力すれば接続出来る。初回は Raspberry Pi 側のユーザ名（デフォルトは pi）とパスワード（セットアップ時に設定したもの）を求められる。\n こちらの方法が公式に案内・提供されているので、下記 tightvncserver を使う方法よりよいと思う。\nここまで追記 2020-03-20\n$ sudo apt-get install tightvncserver でインストールできるので、完了したら\n$ tightvncserver で起動できる。初回は VNC 用にパスワードを設定するよう要求されるので適切なものを設定する。\nmac から接続 Finder のメニューから 移動 \u0026gt; サーバへ接続 を選択し、\n （rp0はホスト名なので以下略）\n以上でひとまずの動作環境は出来た。\n","date":"2020-03-20","id":31,"title":"Raspberry Pi セットアップ 2020 春 ~ SSH + VNC 接続まで","url":"/post/raspberry_pi_setup/"},{"body":"Terms の昇順/降順 hugo の Terms ……このブログに於いては /tags/ と /archives/ について、通常のページでは辞書的に昇順で表示したいが、/archives/ については新しい順になるよう降順で表示したい。そこで /layouts/_default/terms.html を設定したのだけど、もっとスマートな書き方があるのではないかと迷っている。特に {{ if }} 〜 {{ else }} で重複して html を書いてるのどうかと思うんだよなあ……\n{{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;ul class=\u0026#34;terms\u0026#34;\u0026gt; {{ if eq .Title \u0026#34;Archives\u0026#34; }} {{ range .Data.Terms.Alphabetical.Reverse }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;{{ .Page.RelPermalink }}\u0026#34;\u0026gt;{{ .Page.Title }}\u0026lt;/a\u0026gt; ({{ .Count }}) \u0026lt;/li\u0026gt; {{ end }} {{ else }} {{ range .Data.Terms }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;{{ .Page.RelPermalink }}\u0026#34;\u0026gt;{{ .Page.Title }}\u0026lt;/a\u0026gt; ({{ .Count }}) \u0026lt;/li\u0026gt; {{ end }} {{ end }} \u0026lt;/ul\u0026gt; {{ partial \u0026#34;footer.html\u0026#34; . }} ","date":"2020-03-09","id":32,"title":"Archives だけ降順にしたい","url":"/post/sort_term/"},{"body":"  成果物  /search/  生の html を書きたい hugo では Markdown を使う。一般的な Markdown では html を混在して書けるが、 hugo では以下のようになる。\nindex.md\n\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/img.jpg\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; ↓ index.html\n\u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;/img.jpg\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; このように p タグで囲われた状態で出力されるため、たとえば Amazon のアフィリエイトを貼り付けると無駄な改行が入ってしまう。このままでは JavaScript でページを作る上で多少の不都合がある（表現が自由ではない）ので、生の html を出力する shortcode を作成する。\n/layouts/shortcodes/raw.html\n{{ .Inner }} このように使える。\n参照: Simple Shortcode to Insert Raw HTML in Hugo · Ana Ulin\nindex.json を出力する 今回は How to make a client-side search engine with Vue.js and Lunr.js - Fabio Franchino の方法をパク踏襲して、まずは動かしてみる。リンク先のコードにおいて axios で読み込む json に相当する情報を hugo で出力する必要があるので、それを index.json とする。 /layouts/_default/index.json に layout を、config.toml に設定を追加すれば index.xml (RSS)のように出力することが出来る。\n/layouts/_default/index.json\n{{ $items := slice }} {{ $counter := 0 }} {{ range .Site.RegularPages }} {{ if in .Permalink \u0026quot;/post/\u0026quot; }} {{ $counter = add $counter 1 }} {{ $date := .Date.Format \u0026quot;2006-01-02\u0026quot; }} {{ $items = $items | append (dict \u0026quot;id\u0026quot; $counter \u0026quot;title\u0026quot; .Title \u0026quot;body\u0026quot; .Plain \u0026quot;url\u0026quot; .Permalink \u0026quot;date\u0026quot; $date) }} {{ end }} {{ end }} {{ $items | jsonify }} 単純に slice として定義した $items にページの内容を dict として追加していっている。id は今回のソースでは使用するというだけで、別に url を同じく用いてもよいだろうと思う（検証はしていないが）。何も考えず全ページを追加すると /profile/ や /search/ 自身まで対象となるので、リンクに /post/ が含まれるページだけという条件をつけている（if in .Permalink \u0026quot;/post/\u0026quot;）。最終行ではループで組み立てた $items を jsonfy で json 化して出力している。\n同じようなことを解説しているページで .Scratch を使っているパターンがあるが、このように単一ページで用いるだけの変数には必要のないと思う。ドキュメントには allow for writable page- or shortcode-scoped variables. とある。スコープをまたぐときに使うように読めるが、今回は関係ない。物事はシンプルに記述したほうが良いだろう。\nまた config.toml にはこのように。\n[outputs] home = [\u0026quot;html\u0026quot;, \u0026quot;json\u0026quot;, \u0026quot;rss\u0026quot;] 検索ページを設置する search.md\n https://github.com/tbsmcd/tbsmcd.github.io/blob/ed52a5bca0f828d3c046bef2bdc3577d3150c38e/content/search.md  lunr.js はここから、lunr.stemmer.support.js tinyseg.js lunr.ja.js はここからダウンロードする。\nsearch.js\n https://github.com/tbsmcd/tbsmcd.github.io/blob/ed52a5bca0f828d3c046bef2bdc3577d3150c38e/static/js/search.js  検索対象が本文とタイトルなので、そのように指定している。\nlunr-languages の README では多言語に対応する方法として\nthis.use(lunr.multiLanguage('en', 'ru')); と書かれているのだが、同じように日本語を、例えば 'en', 'ja' のように指定しても希望通り動かない（英語だけが有効になる）。これは既知の問題のようだ。\n \u0026ldquo;multiLanguage\u0026rdquo; method doesn't work with Japanese. #45 · MihaiValentin/lunr-languages  そのため今回は this.use(lunr.ja) と日本語だけを検索するよう書いたのだが、もちろん多言語対応していないので次は英単語の resource などを検索できない問題が生じる。そのため姑息的対処として this.resuls = this.searchIndex.search(*${this.search}*) でワイルドカードで検索できるようにした。これで resource なども検索できるのだが、ならばいっそ lunr を使わず Vue だけで検索を作っても良いのではないかという気にもなる…… lunr-languages に貢献するのがいちばん良いのかな。\n以上で検索ページは実現できる。\n今後  全記事を表示してから絞り込み検索するのはページ増えたときに……  ページが増えたときに考えましょう   全記事を json で吐き出すのは……  ページが増えたときに考えましょう    ","date":"2020-03-06","id":33,"title":"Vue.js + lunr.js を使い hugo サイトに全文検索を追加する","url":"/post/added_search/"},{"body":"在宅勤務5週目 新型コロナウイルス感染症（COVID-19）対策としておれが所属する GMO ペパボは東京・福岡で在宅勤務を継続していて、すでに1ヶ月以上出社していない。いわゆるGMO 増田などあったが、まあ実際のところはテックブログ等を読んでもらえば分かるだろう。\n GMO ペパボのリモートワーク状況 2020 - ペパボテックブログ ペパボのパートナーの自宅作業デスクまとめ - ペパボテックブログ  運動不足問題 おれは普段5km程度を自転車で出勤し、オフィスではコーヒーを注いだりトイレに行ったりミーティングをしたりとある程度は歩き、また5km程度を自転車で帰るという生活を送っていた。在宅勤務になるとこれらはほとんど失われる。ジムには定期的に通っているものの（しかしそれも厳しくなりそう）、日常的な運動量が減るのは痛い。だから最近は積極的に散歩をするようにしている。\n散歩は娘（4ヶ月半）を抱っこひもで連れていく。昼休みや退勤後に、安全な道を7kg弱の負荷をかけて歩く。これがなかなか楽しいし役にも立つ。\n三方良し このぐらいの子供は自分で上手く寝ることが出来ない。娘も日によっては昼寝が満足に出来ず、そのせいで逆に夜寝れないなんてことがある。そういうときに抱っこひもで連れて歩くとよく昼寝が出来て、娘の満足度は高い（と勝手に思っている）。妻は妻で日中娘に掛かりきりなので一人の時間が出来ることはありがたいようだ。家族全体としても夜に娘が寝付きやすければありがたい。そしておれ自身も運動量が増えて、娘と触れ合う時間が増えれば楽しい。在宅勤務といえども勤務中は業務遂行に専念すべきなので、娘とのまとまった時間が取れるのはとても良い。 三方良し、これが近江商人の精神である。\n「世間に良し」。まあ、良いんじゃないかな。\n","date":"2020-02-27","id":34,"title":"子を連れて散歩する（三方良し）","url":"/post/walking/"},{"body":"なぜいまさら hugo で画像を最適化（リサイズ）して出力したのときに画像を /static/images/ から /content/post/[各記事]/ 以下に移動させたわけだが、完全に OGP タグのことを忘れていた。\n変更点 /layouts/partials/head_custom.html\n\u0026lt; \u0026lt;meta property=\u0026quot;og:image\u0026quot; content=\u0026quot;{{if .Params.image}}https://tbsmcd.net{{.Params.image}}{{else}}https://tbsmcd.net/images/icon_mono.jpg{{end}}\u0026quot; /\u0026gt; --- \u0026gt; {{ if .Params.image }} \u0026gt; {{ $src := .Params.image }} \u0026gt; {{ $resource := .Page.Resources.GetMatch $src }} \u0026gt; \u0026lt;meta property=\u0026quot;og:image\u0026quot; content=\u0026quot;https://tbsmcd.net{{ $resource.Permalink }}\u0026quot; /\u0026gt; \u0026gt; {{ else }} \u0026gt; \u0026lt;meta property=\u0026quot;og:image\u0026quot; content=\u0026quot;https://tbsmcd.net/images/icon_mono.jpg\u0026quot; /\u0026gt; \u0026gt; {{ end }} 記事ディレクトリ直下にある画像のうち OGP に使いたいファイル名を index.md のメタデータ部分に image: \u0026quot;hoge.jpg\u0026quot; と書いておけば展開される。image: \u0026quot;hoge.jpg\u0026quot; がない場合はデフォルトの画像が表示される。記事直下にない画像ファイルを指定した場合はビルドでエラーになるので気付くことができる。\n","date":"2020-02-23","id":35,"title":"OGP イメージに resource を使う","url":"/post/ogp_using_resource/"},{"body":"   通っているジムが3月から24時間営業になる。入退館管理には Raspberry Pi が使われるようだ。こういうシステムを導入する場合、ハードウェアごと借りるパケージになっていそうだけど、そうではないのかな？いずれにせよハックしてる感じがしてワクワクする。ジムの人が DIY しているとまでは思っていないけど。\n","date":"2020-02-23","id":36,"title":"ハッカブル・ジム","url":"/post/hackable_gym/"},{"body":"  安倍晋三が2018年の記者会見で述べた言葉に「信なくば立たず」がある。これは『論語』顔淵第十二の七にある「民無信不立（民信なくんば立たず）」のことだ。論語を引くほどだから、儒教を「中国思想だから」と否定する偏狭なウヨク連中とは違うのだろう。 さて、次のような一節が論語にはある。\n子路曰、衞君待子而爲政、子將奚先、子曰、必也正名乎、子路曰、有是哉、子之迂也、奚其正、子曰、野哉由也、君子於其所不知、蓋闕如也、名不正則言不順、言不順則事不成、事不成則禮樂不興、禮樂不興則刑罰不中、刑罰不中則民無所錯手足、故君子名之必可言也、言之必可行也、君子於其言、無所苟而已矣、\n金谷治 訳註 『論語』岩波文庫より子路第十三の三\n「名と実があってないと言葉も順当でなく（略）君子は言葉をいい加減にしてはならない」極めて簡潔かつ真っ当な論理であるし、論語の中では解釈も文法も簡単な方だ。記者会見で論語を引用するような安倍晋三であれば、きっとこれも心に留めてるんだろうなとは思う。もっとも、彼が格好をつけて読みもしない論語を引いていなければだけど。もしくは、彼が言葉を理解できていたらだけど。\n なお、小泉進次郎環境大臣の父君もこの言葉を座右の銘としていたらしい。反省はしているが反省が反省と反省に……よく分からないので、父上に言葉の意味を訊いてきて欲しい。父上も……理解してなかったのかもな。\n\n","date":"2020-02-21","id":37,"title":"安倍晋三は論語を読んだのか？もしくは言葉を理解できているのか？","url":"/post/shiro_13_3/"},{"body":"ブログを軽くしたい 林田ドットオンラインというまあまあ狂ったブログがあり、これはペパボの同僚の手になるものだけど、とにかく異常に軽い。WordPress でこれだけ軽いのだから、 hugo ならもっと軽くなるはず。なのでこのブログも軽量路線で行こうという話。\nなにはともあれ画像がデカい 大きければ転送に時間がかかる。これは古代エジプトの時代から不変の原理であり、当時は巨石を丸太のコロを使っただとか、ソリを使っただとか、いずれにせよ重いものを運ぶのには力か工夫が必要である。幸い2020年代を生きている我々は、巨石を運ぶ古代エジプト労働者やイースター島モアイ建造従事者とは違い、ファイルを圧縮したり画像自体の表示領域を小さくすることが許されている。逆に労働の合間にビールを飲むことは許されてはいないが、ここは素直に軽くする方向で行きたい。\nhugo における画像リサイズ 参照\n Image Processing | Hugo Page Resources | Hugo  上の記事を読むと、画像を Page Resource として扱うようにすると画像はリサイズできることがわかる。\nResource として扱う？ 従来\n├── content │ ├── _index.md │ ├── post │ │ ├── added_archives.md │ │ ├── added_favicon.md │ │ ├── hello.md │ │ ├── index_md_is_useful.md │ │ ├── my_desk.md │ │ ├── reading_card.md │ │ ├── reading_card_addition.md │ │ ├── studio_alice.md │ │ └── syntax_highlighting.md │ └── profile.md （略） ├── static │ ├── images │ │ ├── desk.JPG │ │ ├── icon_gen.jpg │ │ ├── icon_mono.jpg │ │ ├── reading_card.jpg │ │ └── studio.jpg 変更後\n├── content │ ├── _index.md │ ├── post │ │ ├── added_archives │ │ │ └── index.md │ │ ├── added_favicon │ │ │ ├── icon_gen.jpg │ │ │ ├── icon_mono.jpg │ │ │ └── index.md │ │ ├── hello │ │ │ └── index.md │ │ ├── index_md_is_useful │ │ │ └── index.md │ │ ├── my_desk │ │ │ ├── desk.JPG │ │ │ └── index.md │ │ ├── reading_card │ │ │ ├── card.jpg │ │ │ └── index.md │ │ ├── reading_card_addition │ │ │ └── index.md │ │ ├── studio_alice │ │ │ ├── index.md │ │ │ └── studio.jpg │ │ └── syntax_highlighting │ │ └── index.md │ └── profile.md という感じでまずは画像を記事ごとに保持する。そうすると画像を Resource として扱えるようになり、Image Processing が使えるようになる。\nshortcode 以下のような shortcode を用意する\n/layouts/shortcodes/img800x.html\n{{ $src := .Get \u0026#34;src\u0026#34; }} {{ $original := .Page.Resources.GetMatch $src }} {{ if $original }} {{ $resized := $original.Resize \u0026#34;800x q90\u0026#34; }} \u0026lt;a href=\u0026#34;{{ $original.RelPermalink }}\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $resized.RelPermalink }}\u0026#34; alt=\u0026#34;{{ .Get \u0026#34;alt\u0026#34; }}\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; {{ end }} Resize \u0026quot;800x\u0026quot; の部分で幅800を指定している。例えば幅400縦200の画像なら Resize \u0026quot;400x200\u0026quot; だし、縦300の画像なら Resize \u0026quot;x300\u0026quot; となる。q90 というのは jpeg のクオリティ。このあたりは上記公式ドキュメントを読めば分かるだろう。\n……と、このような shortcode を用意し、*.md の中でファイル名と同名で呼べば良い。\n例えばこんな感じで\nshortcode の解説は後日別記事で行う（かもしれない）（いま酒飲んでて後のことはよく分からない）（期待しないで）。\n実際にこの作業をおこなった記事 これとかこれとか。\n画像の再配置は全ページについて行った。\n補足 OGP タグについてはこちら\n","date":"2020-02-21","id":38,"title":"hugo で画像を最適化して出力する","url":"/post/image_processing/"},{"body":"元画像の準備  Twitter などで使っているアイコンを白黒で作り直した。今回は Piskel を利用した。\nfavicon 化   Favicon \u0026amp; App Icon Generator を利用した。サイト名から分かるとおり、 favicon だけではなくスマートフォン用の App Icon も作成してくれるし、画像のように \u0026lt;head\u0026gt; 内のコードまで用意してくれるから頭を使わなくて良い。\nHead にコードを追加 hugo ではテーマの layout 以下にあるファイルよりブログの layout 以下の同名ファイルが優先して利用される1。通常 \u0026lt;head\u0026gt; 内を変更したい場合はテーマの layout/partials/header.html をコピーし、ブログのディレクトリに同名で保存して編集すれば良い。このブログで使っているテーマは少し事情が違い header.html 内で空の header_custom.html を読み込むようになっているので、今回は favicon 用のコードを書いた head_custom.html をブログの同一 path に設置した。\n  hugo の layout の優先順位については公式ドキュメント参照のこと。 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2020-02-16","id":39,"title":"hugo に favicon を追加したメモ","url":"/post/added_favicon/"},{"body":"参照 Scrapbox で読書カードを作ってみる | tbsmcd\n要約→項目カード, 要約→読書カードという順番について 書籍によって向き・不向きがあるはずなのだが、それを無視してしまった。今回『エンジニアリング組織論への招待　～不確実性に向き合う思考と組織のリファクタリング』を題材に始めたのだが、本書は幅広い知識の総覧としての性質をもつ。この場合当然に要約から項目カードが作り出せるし、要約からこそ全体像を描ける。しかし特定の分野を深く掘るような書籍の場合は読書カードから項目カードを作るやり方が向いているのかもしれない。\n『読書家の新技術』について 古書店に注文したものがようやく届いた。今夜から読んでいこうと思う。\n\n\n","date":"2020-02-15","id":40,"title":"Scrapbox で読書カードを作ってみる 補足","url":"/post/reading_card_addition/"},{"body":"  読書カードとは 学生の頃に読んだ呉智英『読書家の新技術』をいま思い出した。本書技術編には読書カードの作り方が書かれている。読書カードとはその本の全体像を書き、あとで読み返すときに参考にするもの。読書カードが溜まったら項目カードを作る。項目カードはいわば個人的な索引で、その項目のカードを見れば言及している本を探せるようになる。 これが読書カードの概要であるが、かつて読んだ『読書家の新技術』文庫は手元になく北大恵迪寮のどこかに埋もれているはずで、この記述の正確性は担保できない（いまから中古を注文する→注文した！）。\n\n自分なりの応用法 本書の読書カードは手書き時代のものだ。デジタル化により検索性と編集容易性が共に向上した現在においてはアップデートされるべきアイデアだと思う。今回の試みではラフとしてまずチャプター/章ごとに要約を作っていく。要約を作る際に項目カード化しそうな語については #エンジニアリング のような形式で書いておく。Scrapbox においてはハッシュタグのリンク先はページ化されるので、あとで埋めていけば良いだろう。埋めるまでもなければハッシュを削除する。\nリンク  tbsmcd の読書メモ  まずは『エンジニアリング組織論への招待　～不確実性に向き合う思考と組織のリファクタリング』（広木大地）を題材に。\n補足あり\n\n","date":"2020-02-10","id":41,"title":"Scrapbox で読書カードを作ってみる","url":"/post/reading_card/"},{"body":"  🤔\n プロすごい 写真論とか撮影技術とか分からないけど、上機嫌とはいえない0歳児からどうにか引き出した0.1秒の笑顔を切り取る技術は子供専門スタジオだからこそだし、撮影しているさまを見るだけでも十分面白く勉強にもなったので、あれには財布の紐も緩むというもの。\n各所から頂いた出産祝で払いました……\n","date":"2020-02-09","id":42,"title":"スタジオアリスの撮影料（3000円）無料券をもらったので行った","url":"/post/studio_alice/"},{"body":"  あまりきれいでもないし整理もされていない ペパボのパートナーの自宅作業デスクまとめ - ペパボテックブログ\nデスク環境さらしなどをやっていると「きれいに整理されてるけど、写真を取るときに片付けたんでしょ？」みたいな反応があって、まあそりゃ人間自身も100%普段着で写真に写る必要もないわけだから「机だって同じだよ」と言いたくなるのだけど、とにかく敢えて普段どおりの雑然とした机の写真を撮ってみた。\n机の上や周りににあるもの 技術書無いの？ 技術書は本棚にあるか、電子書籍で買っている。最近は電子書籍が多い。机の上にある本についてはいま大切だと思っている本を置いている。\n        市バスのりば 神戸市交通局で買え(る|た)もの。気に入っていていまだ開封せずに使っている。\n音 ヤマハのスピーカーと FX-AUDIO のデジタルアンプ。金属ラックにスピーカーを置くのは禁忌だけど、アンカー代わりにコンクリートブロック（モノタロウで買った）を置き、ゴムシートを敷くことで空中に擬似的に強固な地盤を作れたと思う。\nG-レコ BD 本体より絵コンテ集の方がデカい。絵コンテが本体。\nヘッドセット ミーティングをオンラインで行うときにとても便利。\n椅子 あ、いちおう椅子はオカモトのバロンの中古で、送料込みで2万円。ただし自分で修理ができる人向けではある。\n","date":"2020-02-06","id":43,"title":"テックブログに載らない作業環境","url":"/post/my_desk/"},{"body":"こういう感じ \u0026lt;?php class SimpleClass { // プロパティの宣言  public $var = \u0026#39;a default value\u0026#39;; // メソッドの宣言  public function displayVar() { echo $this-\u0026gt;var; } } コードは PHP: クラスの基礎 - Manual  より\nテーマの編集 対応する Pull Request\nAdd syntax highlighting #1\nシンタックスハイライト用の CSS を生成する。コマンドはこちらを参照のこと。/ style-name はここから好きなものを選べば良い。今回は manni を選んだ。\n$ hugo gen chromastyles --style [style-name] \u0026gt; code.css ついでにインラインコードの背景を manni と合わせた。\n生成した CSS を static/css/ 以下に配置し、html から読み込みために header を編集する。\nローカルでビルドする場合はブログのソースに CSS を追加すれば良いと思う。今回は Github Actions でビルドしているため、テーマの方に追加した。その場合でもテーマに追加せず、ビルドスクリプト上で配置することも出来ると思う。\nconfig.toml の編集 対応する Pull Request\nシンタックスハイライト適用 #5\n# シンタックスハイライトを有効に pygmentsUseClasses = true # github 風に ``` で囲む pygmentsCodefences = true ついでにシンタックスハイライト無しの pre の背景色も合わせた。\naaa あああ おわりに ようやくコードを書けるようになった。余計な装飾はいらないが、必要な機能は欲しいというわがままな欲求はこうやって叶えていく。本筋とは関係ないが Github で管理すると機能追加した P/R をブログに載せれるので便利。\n","date":"2020-02-05","id":44,"title":"hugo でシンタックスハイライトを追加した","url":"/post/syntax_highlighting/"},{"body":"変更点 対応する Pull Request\nアーカイブを追加 #4\nただし後述の通り、日付フォーマットには 2006-01 を使う。\n簡単な説明  footer は config.toml で定義しているので変更 すでにあるページには追記する必要があるので手動で変更  archives: [\u0026quot;2020-02\u0026quot;] 記事が2つしか無かったので手動だったが、多ければスクリプトを書く必要がありそう   config.toml に [taxonomies] を追加 archetypes に archives: [\u0026quot;{{ dateFormat \u0026quot;2020-02\u0026quot; .Date }}\u0026quot;] を追加したが、このフォーマットに対応していないのか3030年とかになる  archives: [\u0026quot;2020-02\u0026quot;] のように決め打ちしといても間違いはなさそう  修正 \u0026amp;\u0026amp; 追記  archives: [\u0026quot;{{ dateFormat \u0026quot;2006-01\u0026quot; .Date }}\u0026quot;] としたら問題がなかった ドキュメントで使用されている日付(2006/01/02)を採用したら問題は起きない        ","date":"2020-02-03","id":45,"title":"Archives ページを導入した","url":"/post/added_archives/"},{"body":"前提 自分のブログはなるべく装飾のないものにしたかったので hugo-xminを採用した(注: その後フォークしたものを使うことに)。ヘッダも余計なものに見えたので削除している。しかし Home はある程度情報を追加したいというわがままな欲求がある。\nやったこと xmin のサンプルサイトの HUGO XMIN から usage of this theme. の部分は content/_index.markdown に書かれているようだ。とりあえず拡張子を .md に変更して自分でも追加してみた。\n結果 すごくどうでもいいことを書ける場所が出来た。いらないものはいらないが、欲しいものは欲しいので便利。自前で新しいテーマ（github の markdown に適用される CSS でも使おうかと……）を作ろうとしていたが、その必要はなくなった。\n","date":"2020-02-02","id":46,"title":"hugo-xmin で `_index.md` を設定すると便利だった","url":"/post/index_md_is_useful/"},{"body":"使用したもの  hugo GitHub Actions による GitHub Pages への自動デプロイ hugo-xmin  上記をフォークしたものに変更 2020-02-03  MIT ライセンスの賜物     ムームードメイン  ","date":"2020-02-02","id":47,"title":"ブログを作り直した","url":"/post/hello/"}]